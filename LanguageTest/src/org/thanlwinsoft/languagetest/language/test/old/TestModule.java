/*
 * -----------------------------------------------------------------------
 *  File:          $Source: /home/keith/cvsroot/projects/LanguageAids/uk/co/dabsol/stribley/language/test/TestModule.java,v $
 *  Version:       $Revision: 1.10 $
 *  Last Modified: $Date: 2004/06/20 11:50:02 $
 * -----------------------------------------------------------------------
 *  Copyright (C) 2003 Keith Stribley <jungleglacier@snc.co.uk>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 * -----------------------------------------------------------------------
 */

package org.thanlwinsoft.languagetest.language.test.old;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.util.Date;
import java.util.TreeSet;
import java.util.TreeMap;
import java.util.Set;
import java.util.Vector;
import java.util.SortedSet;
import java.util.Iterator;
import java.util.Hashtable;
import java.util.HashMap;
import java.util.Properties;
import java.awt.Font;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.DefaultMutableTreeNode;

import org.xml.sax.*;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;

import org.thanlwinsoft.languagetest.util.RelativePath;
import org.w3c.dom.Element;

import org.jfree.io.IOUtils;

/**
 *
 * @author  keith
 */
public class TestModule implements Comparable, TestComponent
{
    private final static String LANGUAGE_MODULE_TAG = "LanguageModule";
    private final static String NATIVE_FONT_ATTRIB = "nativeFont";
    private final static String FOREIGN_FONT_ATTRIB = "foreignFont";
    private final static String NATIVE_FONT_SIZE_ATTRIB = "nativeFontSize";
    private final static String FOREIGN_FONT_SIZE_ATTRIB = "foreignFontSize";
    private final static String NATIVE_FONT_STYLE_ATTRIB = "nativeFontStyle";
    private final static String FOREIGN_FONT_STYLE_ATTRIB = "foreignFontStyle";
    private final static String NAME_ATTRIB = "name";
    private final static String UNIQUE_ID = "id";
    private final static String TEST_TAG = "TestItem";
    //private final static String TEST_NAME_ATTRIB = "name";
    private final static String NATIVE_TAG = "NativeLang";
    private final static String FOREIGN_TAG = "ForeignLang";
    private final static String SOUND_TAG = "SoundFile";
    private final static String PICTURE_TAG = "Img";
    private final static String PLAY_START_ATTRIB = "start";
    private final static String PLAY_END_ATTRIB = "end";
    private final static String SOUND_LENGTH_ATTRIB = "length";
    private final static String CREATION_TIME = "creationTime";
    private final static String CREATOR = "creator";
    
    public final static String LANG_TAG = "Lang";
    public final static String LANG_TYPE_ATTRIB = "type";
    public final static String LANG_CODE_ATTRIB = "lang";
    public final static String LANG_NATIVE = "native";
    public final static String LANG_FOREIGN = "foreign";
    public final static String FONT_NAME_ATTRIB = "font";
    public final static String FONT_SIZE_ATTRIB = "fontSize";
    public final static String FONT_STYLE_ATTRIB = "fontStyle";
    
    private final int NATIVE_FONT_SIZE = 18;
    private final int FOREIGN_FONT_SIZE = 36;
    private final String STYLE_SHEET = "xml-stylesheet";
    private final String XSL_LINK = "href=\"LanguageTest.xsl\" type=\"text/xsl\"";
    private final String XML_COMMENT = 
        "\nThis file was generated by the Language Test program on " 
        + new Date() + 
        "\nIt is not designed for editing by hand.\n";
    private final static String UNKNOWN = "Unknown";
    private final static String XSL_FILE = "LanguageTest.xsl";
    private final static String MODULE_FILE_EXT = ".xml";
    private int uniqueId = 0;
    private long creationTime = -1;
    //private String name = UNKNOWN;
    private TreeSet testList = null;
    private File file = null;
    //private Font nativeFont = null;
    //private Font foreignFont = null;
    private boolean selected = true;
    private MutableTreeNode moduleNode = null;
    private TreeMap missingFiles = null;
    private Hashtable itemHash = null;
    private boolean modified = false;
    private HashMap nativeFonts = null;
    private HashMap foreignFonts = null;
    private HashMap names = null;
    private boolean readOnly = false;
    private static DocumentBuilderFactory dfactory = null;
    private static DocumentBuilder docBuilder = null;
    private static TransformerFactory tfactory = null;
    private static Transformer serializer = null;
    
    /** Creates a new instance of TestModule */
    public TestModule(File file) throws FileNotFoundException, TestModule.ParseException
    {
        testList = new TreeSet();
        missingFiles = new TreeMap();
        itemHash = new Hashtable();
        nativeFonts = new HashMap();
        foreignFonts = new HashMap();
        names = new HashMap();
        moduleNode = new DefaultMutableTreeNode(this,true);
        this.file = file;
        open(file);
        readOnly = !(file.canWrite());
        System.out.println("Loaded " + getName() + " with " + 
                           testList.size() + " test items.");
    }
    public Set getLanguages(int langType)
    {
        if (langType == UniversalLanguage.NATIVE_LANG)
        {
            return getNativeLanguages();
        }
        else
        {
            return getForeignLanguages();
        }
    }
    
    
    public Set getNativeLanguages()
    {
        return nativeFonts.keySet();        
    }
    
    public Set getForeignLanguages()
    {
        return foreignFonts.keySet();
    }
    
    public String toString()
    {
        return (String)names.get(LanguageConfig.getCurrent().getNativeLanguage());
    }
    
    public boolean isSelected() { return selected; }
    public void toggleSelected()
    {
        if (selected == true) selected = false;
        else selected = true;
    }
    /**
     * @return Set of TestItem objects
     */
    public Set getTestList() { return testList; }
    
    
    public Font getFont(UniversalLanguage ul, int langType) 
    {
        if (langType == UniversalLanguage.NATIVE_LANG)
        {
            return getNativeFont(ul);
        }
        else
        {
            return getForeignFont(ul);
        }
    }
    public Font getNativeFont() 
    { 
        return getNativeFont(LanguageConfig.getCurrent().getNativeLanguage()); 
    }
    public Font getForeignFont() 
    { 
        return getForeignFont(LanguageConfig.getCurrent().getForeignLanguage()); 
    }
    public Font getNativeFont(UniversalLanguage ul) 
    {
        if (nativeFonts.containsKey(ul))
        {
            return (Font)nativeFonts.get(ul); 
        }
        return null;
    }
    public Font getForeignFont(UniversalLanguage ul) 
    { 
        return (Font)foreignFonts.get(ul); 
    }
    public void setFont(Font newFont, UniversalLanguage ul, int langType)
    {
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        
        if (langType == UniversalLanguage.NATIVE_LANG)
        {
            setNativeFont(newFont, ul);
        }
        else
        {
            setForeignFont(newFont, ul);
        }
    }
    public void setNativeFont(Font newFont, UniversalLanguage ul) 
    { 
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        
        nativeFonts.put(ul,newFont); 
    }
    public void setForeignFont(Font newFont, UniversalLanguage ul) 
    { 
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        
        foreignFonts.put(ul, newFont); 
    }
    public void setNativeFont(Font newFont) 
    { 
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        
        nativeFonts.put(LanguageConfig.getCurrent().getNativeLanguage(),
                        newFont); 
    }
    public void setForeignFont(Font newFont) 
    { 
        if (readOnly)
            throw new IllegalArgumentException("TestModule is readonly");
        foreignFonts.put(LanguageConfig.getCurrent().getForeignLanguage(), 
                         newFont); 
    }
    /**
     * Removes both the name and font for the specified native language.
     */
    public void removeNativeLanguage(UniversalLanguage ul)
    {
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        if (nativeFonts.containsKey(ul))
        {
            nativeFonts.remove(ul);
        }
        if (names.containsKey(ul))
        {
            names.remove(ul);
        }
    }
    public void removeForeignLanguage(UniversalLanguage ul)
    {
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        if (foreignFonts.containsKey(ul))
        {
            foreignFonts.remove(ul);
        }
    }
    public String getName(UniversalLanguage ul) 
    { 
        Object name = names.get(ul);
        if (name != null)
        {
            return (String)name;
        }
        return "";
    }
    /** No name is specified so try to give the name for the current language
     * if none exists default to the first name in the hash.
     */
    public String getName() 
    { 
        if (names.containsKey(LanguageConfig.getCurrent().getNativeLanguage()))
        {
            return getName(LanguageConfig.getCurrent().getNativeLanguage()); 
        }
        else
        {
            Iterator i = names.values().iterator();
            if (i.hasNext())
            {
                return i.next().toString();
            }
        }
        return ""; // default to empty string
    }
    public void setName(String newName, UniversalLanguage ul) 
    {
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        
        names.put(ul, newName); 
    }
    public void setName(String newName) 
    { 
        if (readOnly) 
            throw new IllegalArgumentException("TestModule is readonly");
        
        names.put(LanguageConfig.getCurrent().getNativeLanguage(), newName); 
    }
    public MutableTreeNode getTreeNode() { return moduleNode; }
    public TreeMap getMissingFileList() { return missingFiles; }
    
    public File getFile() { return file; }
    public void setFile(File newFile) { this.file = newFile; }
    
    protected void open(File xmlFile) throws TestModule.ParseException
    {
        long defaultTime = -1;
        // initialise Id to hash code, time to file time
        // if module already has an id, time then these will be overwitten
        //  with the saved values
        uniqueId = this.hashCode();
        if (xmlFile.exists()==true)
        {
            org.w3c.dom.Document doc = null;
            try 
            {
                DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
                DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
                doc = docBuilder.parse(new InputSource(xmlFile.getAbsolutePath()));
                defaultTime = xmlFile.lastModified();
                creationTime = defaultTime;
            }
            catch (ParserConfigurationException pce)
            {
                System.out.println(pce.getMessage());
                throw new TestModule.ParseException(pce.toString());
            }
            catch (SAXException se)
            {
                System.out.println(se.getMessage());
                throw new TestModule.ParseException(se.toString());
            }
            catch (IOException ioe)
            {
                System.out.println(ioe.getMessage());
                throw new TestModule.ParseException(ioe.toString());
            }
            if (doc != null)
            {
                doc.normalize(); // join adjacent text nodes
                org.w3c.dom.NodeList top = doc.getElementsByTagName(LANGUAGE_MODULE_TAG);
                
                if (top.getLength()>0)
                {
                    org.w3c.dom.Element moduleTag = (org.w3c.dom.Element)top.item(0);
                    if (moduleTag.hasAttribute(NATIVE_FONT_ATTRIB))
                    {
                        Font nativeFont = readFont(moduleTag, NATIVE_FONT_ATTRIB,
                                                            NATIVE_FONT_STYLE_ATTRIB, 
                                                            NATIVE_FONT_SIZE_ATTRIB,
                                                            NATIVE_FONT_SIZE);
                        if (nativeFont != null) setNativeFont(nativeFont);
                        Font foreignFont = readFont(moduleTag, FOREIGN_FONT_ATTRIB,
                                                             FOREIGN_FONT_STYLE_ATTRIB, 
                                                             FOREIGN_FONT_SIZE_ATTRIB,
                                                             FOREIGN_FONT_SIZE);
                        if (foreignFont != null) setForeignFont(foreignFont);
                    }
                    if (moduleTag.hasAttribute(NAME_ATTRIB))
                    {
                        setName(moduleTag.getAttribute(NAME_ATTRIB));
                    }
                    if (moduleTag.hasAttribute(UNIQUE_ID))
                    {
                        try
                        {
                            // id stored as hex
                            uniqueId = Integer.valueOf(moduleTag
                                .getAttribute(UNIQUE_ID),16).intValue();
                        }
                        catch (NumberFormatException nfe)
                        {
                            System.out.println(nfe);
                        }                        
                    }
                    else modified = true;
                    if (moduleTag.hasAttribute(CREATION_TIME))
                    {
                        try
                        {
                            creationTime = 
                                Long.valueOf(moduleTag
                                .getAttribute(CREATION_TIME)).longValue();
                        }
                        catch (NumberFormatException nfe)
                        {
                            System.out.println(nfe);
                        }
                    }
                    else
                    {
                        modified = true;
                        defaultTime++; // increment default time by 1ms
                        // to give every test item a different time
                    }
                    org.w3c.dom.NodeList testNodes = top.item(0).getChildNodes();
                    for (int t=0; t<testNodes.getLength(); t++)
                    {
                        if (testNodes.item(t).getNodeType() == 
                            org.w3c.dom.Node.ELEMENT_NODE)
                        {
                            if (testNodes.item(t).getNodeName() == LANG_TAG)
                            {
                                org.w3c.dom.Element langElement = 
                                    (org.w3c.dom.Element)testNodes.item(t);
                                readLanguage(langElement);
                            }
                            else if (testNodes.item(t).getNodeName() == TEST_TAG)
                            {
                                org.w3c.dom.Element testElement = 
                                    (org.w3c.dom.Element)testNodes.item(t);
                                readTestItem(testElement, defaultTime);
                            }
                        }
                    }
                }
                // if data was missing in the module file save it now
                // This probably means that the file format has changed
                // so this forces it to be saved in the new format.
                // May need rethinking if the format changes drastically.
                if (modified) 
                {
                    if (save())
                    {
                        modified = false;
                    }
                    else
                    {
                        throw new TestModule.ParseException
                            ("File format has changed, but save in new format"
                             + " failed.\n" + 
                             "This may mean that some features will not"
                             + " work properly. Please make sure that you have "
                             + "write permission to the file and try loading it"
                             + " again");
                    }   
                }
            }
            
        }
        else // create a new module using
        {
            int extIndex = file.getName().toLowerCase().indexOf(MODULE_FILE_EXT);
            if (extIndex >= 0)
            {
                setName(file.getName().substring(0,extIndex));
            }
            else
            {
                setName(file.getName());
            }
            LanguageConfig lc = LanguageConfig.getCurrent();
            UserConfig uc = UserConfig.getCurrent();
            setForeignFont(uc.getForeignDefaultFont(lc.getForeignLanguage()));
            setNativeFont(uc.getNativeDefaultFont(lc.getNativeLanguage()));
            creationTime = new Date().getTime();
        }
    }
    
    protected void readLanguage(org.w3c.dom.Element langElement)
        throws org.w3c.dom.DOMException
    {
        UniversalLanguage ul = 
            new UniversalLanguage(langElement.getAttribute(LANG_CODE_ATTRIB));
        HashMap fontMap = null;
        int defaultFontSize = NATIVE_FONT_SIZE;
        if (langElement.getAttribute(LANG_TYPE_ATTRIB).equals(LANG_NATIVE))
        {
            fontMap = nativeFonts;
            defaultFontSize = NATIVE_FONT_SIZE;
            org.w3c.dom.NodeList nodes = langElement.getChildNodes();
            StringBuffer nameBuffer = new StringBuffer();
            for (int t = 0; t<nodes.getLength(); t++)
            {
                org.w3c.dom.Node node = nodes.item(t);
                if (node.getNodeType() == org.w3c.dom.Node.TEXT_NODE)
                {
                    nameBuffer.append(node.getNodeValue());
                }
            }
            names.put(ul, nameBuffer.toString());
        }
        else if (langElement.getAttribute(LANG_TYPE_ATTRIB).equals(LANG_FOREIGN))
        {
            fontMap = foreignFonts;
            defaultFontSize = FOREIGN_FONT_SIZE;
        }
        if (fontMap != null)            
        {
            Font font = readFont(langElement, FONT_NAME_ATTRIB,
                                 FONT_STYLE_ATTRIB, 
                                 FONT_SIZE_ATTRIB,
                                 defaultFontSize);
            fontMap.put(ul,  font);
        }
    }
    
    protected void readTestItem(org.w3c.dom.Element testElement, 
                                long defaultTime)
    {
        //String testName = UNKNOWN;
        //testName = testElement.getAttribute(TEST_NAME_ATTRIB);
        TestItem newTest = new TestItem(this);
        long itemTime = defaultTime;
        if (testElement.hasAttribute(CREATION_TIME))
        {
            try
            {
                itemTime = 
                    Long.valueOf(testElement
                    .getAttribute(CREATION_TIME)).longValue();
            }
            catch (NumberFormatException nfe)
            {
                System.out.println(nfe);
            }
        }
        else
        {
            modified = true;
            defaultTime++; // increment default time by 1ms
            // to give every test item a different time
        }
        String itemCreator = UNKNOWN;
        if (testElement.hasAttribute(CREATOR))
        {
            itemCreator = testElement.getAttribute(CREATOR);
            // a zero length name will cause problems so
            // change to a known string in that case
            if (itemCreator.length() == 0) 
            {
                itemCreator = UNKNOWN;
            }
        }
        else modified = true;
        // TBD check time unique in module
        newTest.setCreationTime(itemTime);
        newTest.setCreator(itemCreator);
        org.w3c.dom.NodeList testItems = 
            testElement.getChildNodes();
        for (int n=0; n<testItems.getLength(); n++)
        {   
            if (testItems.item(n).getNodeType() == 
                org.w3c.dom.Node.ELEMENT_NODE)
            {
                if (testItems.item(n).getNodeName() ==
                    NATIVE_TAG)
                {
                    Element e = (Element)testItems.item(n);
                    if (e.hasAttribute(LANG_CODE_ATTRIB))
                    {
                        UniversalLanguage ul = 
                            new UniversalLanguage(e.getAttribute(LANG_CODE_ATTRIB));
                        newTest.setNative(getElementText(testItems.item(n)), ul);
                    }
                    else
                    {
                        newTest.setNative(
                            getElementText(testItems.item(n)));
                    }
                }
                else if (testItems.item(n).getNodeName() ==
                         FOREIGN_TAG)
                {
                    Element e = (Element)testItems.item(n);
                    if (e.hasAttribute(LANG_CODE_ATTRIB))
                    {
                        UniversalLanguage ul = 
                            new UniversalLanguage(e.getAttribute(LANG_CODE_ATTRIB));
                        newTest.setForeign(getElementText(testItems.item(n)), ul);
                    }
                    else
                    {
                        newTest.setForeign(
                            getElementText(testItems.item(n)));
                    }
                }
                else if (testItems.item(n).getNodeName() ==
                         SOUND_TAG)
                {

                    newTest.setSound(getElementText(testItems.item(n)));
                    org.w3c.dom.Element element = (org.w3c.dom.Element)testItems.item(n);
                    if (element.hasAttribute(PLAY_START_ATTRIB))
                    {
                        newTest.setPlayStart
                            (Long.parseLong(element.getAttribute(PLAY_START_ATTRIB)));
                    }
                    if (element.hasAttribute(PLAY_END_ATTRIB))
                    {
                        newTest.setPlayEnd
                            (Long.parseLong(element.getAttribute(PLAY_END_ATTRIB)));
                    }
                    if (element.hasAttribute(SOUND_LENGTH_ATTRIB))
                    {
                        newTest.setSoundLength
                            (Long.parseLong(element.getAttribute(SOUND_LENGTH_ATTRIB)));
                    }
                    checkLinkFile(newTest.getSoundFile(), newTest);
                }
                else if (testItems.item(n).getNodeName() ==
                         PICTURE_TAG)
                {
                    newTest.setPicture(getElementText(testItems.item(n)));
                    checkLinkFile(newTest.getPictureFile(), newTest);
                }
            }
        }
        insertTestItem(newTest);
                        
    }
    
    /** Check whether the file linked to exists. If it doesn't record it in a
     * list of missing files, if it is not already marked as missing.
     */
    protected void checkLinkFile(File file, TestItem item)
    {
        if (file!=null)
        {
            if (!file.exists()||
                !file.canRead()||
                !file.isFile())
            {
                if (missingFiles.containsKey(file))
                {
                    ((Vector)missingFiles.get(file)).add(item);
                }
                else
                {
                    Vector itemList = new Vector();
                    itemList.add(item);
                    missingFiles.put(file, itemList);
                }
            }
        }
    }
    
    /**
     * Reads the font from an XML element with the specified attributes
     * for the font parameters. If some of the data is missing, the font 
     * defaults to a plain styled default font with the specified size.
     */
    public static Font readFont(org.w3c.dom.Element moduleTag,
                                            String fontNameAttrib, 
                                            String fontStyleAttrib, String fontSizeAttrib,
                                            int defaultFontSize)
    {
        String fontName = null;
        int fontStyle = Font.PLAIN;
        int fontSize = defaultFontSize;
        if (moduleTag.hasAttribute(fontNameAttrib))
        {
            fontName = moduleTag.getAttribute(fontNameAttrib);
        } 
        try
        {
            if (moduleTag.hasAttribute(fontStyleAttrib))
            {
               fontStyle = Integer.parseInt(moduleTag.getAttribute(fontStyleAttrib));
            }
            if (moduleTag.hasAttribute(fontSizeAttrib))
            {
               fontSize = Integer.parseInt(moduleTag.getAttribute(fontSizeAttrib));
            }
        }
        catch (NumberFormatException nfe)
        {
            System.out.println(nfe);
        }
        return new Font(fontName, fontStyle, fontSize);       
    }
            
    
    public void insertTestItem(TestItem newTest)
    {
        testList.add(newTest);
        itemHash.put(new Long(newTest.getCreationTime()),newTest);
        SortedSet testsBefore = testList.headSet(newTest);
        if (testsBefore == null)
        {
            moduleNode.insert(newTest.getTreeNode(),0);
        }
        else
        {
            moduleNode.insert(newTest.getTreeNode(),testsBefore.size());
        }
    }
    
    public void removeTestItem(TestItem oldItem)
    {
        testList.remove(oldItem);
        itemHash.remove(new Long(oldItem.getCreationTime()));
    }
    
    public void resortItems()
    {
        testList = new TreeSet(testList);
        // now sort out nodes
        // first remove all old leaves
        while (!moduleNode.isLeaf())
        {
            moduleNode.remove(0);
        }
        Iterator i = testList.iterator();
        int childIndex = 0;
        while (i.hasNext())
        {
            TestItem item = (TestItem)i.next();
            moduleNode.insert(item.getTreeNode(),childIndex++);
        }
    }
    /** 
     * looks for a test item with the same creation time and creator as 
     * specified. Returns null if item not found.
     */
    public TestItem getItemByCreationTime(long creationTime, String author)
    {
        TestItem item = null;
        Long key = new Long(creationTime);
        if (itemHash.containsKey(key))
        {
            item = (TestItem)itemHash.get(key);
            // check author is the same
            if (!item.getCreator().equals(author))
            {
                System.out.println(item + " has a different creator.");
                item = null;                
            }
        }
        return item;
    }
    
    public org.w3c.dom.Document createXmlDoc(File refDir, boolean currentLangOnly)
    {
        org.w3c.dom.Document doc = null;
        try
        {
            // reuse factory objects between module instances
            if (dfactory == null)
            {
                dfactory = DocumentBuilderFactory.newInstance();
                docBuilder = dfactory.newDocumentBuilder();
            }
            doc = docBuilder.newDocument();
            // add a comment to explain file
            org.w3c.dom.Comment comment = doc.createComment(XML_COMMENT);
            doc.insertBefore(comment,null);
            // add a style sheet link so can be viewed in web browser
            org.w3c.dom.ProcessingInstruction style = 
                doc.createProcessingInstruction(STYLE_SHEET, XSL_LINK);
            doc.insertBefore(style,null);   
            // create top level element
            org.w3c.dom.Element top = doc.createElement(LANGUAGE_MODULE_TAG);
            //top.setAttribute(NAME_ATTRIB,getName());
            top.setAttribute(CREATION_TIME, Long.toString(creationTime));
            top.setAttribute(UNIQUE_ID, Integer.toHexString(uniqueId));
            /*
            Font nativeFont = getNativeFont();
            if (nativeFont != null)
            {
                top.setAttribute(NATIVE_FONT_ATTRIB, nativeFont.getFontName());
                top.setAttribute(NATIVE_FONT_SIZE_ATTRIB, 
                Integer.toString(nativeFont.getSize()));
                top.setAttribute(NATIVE_FONT_STYLE_ATTRIB, 
                Integer.toString(nativeFont.getStyle()));
            }
            Font foreignFont = getForeignFont();
            if (foreignFont != null)
            {
                top.setAttribute(FOREIGN_FONT_ATTRIB,foreignFont.getFontName());
                top.setAttribute(FOREIGN_FONT_SIZE_ATTRIB, 
                Integer.toString(foreignFont.getSize()));
                top.setAttribute(FOREIGN_FONT_STYLE_ATTRIB, 
                Integer.toString(foreignFont.getStyle()));
            }
             */
            doc.insertBefore(top, null);
            createLangTags(doc, top, nativeFonts,  LANG_NATIVE, currentLangOnly);
            createLangTags(doc, top, foreignFonts,  LANG_FOREIGN, currentLangOnly);
            
            Iterator i = testList.iterator();
            while (i.hasNext())
            {
                TestItem item = (TestItem)i.next();
                // integrity check that item really is for this module
                if (item.getModule() == this)
                {
                    top.insertBefore(createItemElement(doc, item, refDir, 
                                                       currentLangOnly), null);
                }
                else
                {
                    System.out.println("!!! test item " + item.getName() +
                        " in module " + item.getModule().getName() +
                        " but reference still left in " + 
                        this.getName() );
                }
            }
        }
        catch (ParserConfigurationException e)
        {
            System.out.println(e.getMessage());
            // from copy of xsl file so not worth giving false for this
            doc = null;
        }
        return doc;
    }
    
    protected void createLangTags(org.w3c.dom.Document doc, 
                                  org.w3c.dom.Element top, 
                                  HashMap fonts, 
                                  String langType,
                                  boolean currentLangOnly)
    {
        // iterate over languages
        Iterator f = fonts.keySet().iterator();
        UniversalLanguage current = null;
        if (langType.equals(LANG_NATIVE))
        {
            current = LanguageConfig.getCurrent().getNativeLanguage();
        }
        else
        {
            current = LanguageConfig.getCurrent().getForeignLanguage();
        }
        while (f.hasNext())
        {
            UniversalLanguage ul = (UniversalLanguage)f.next();
            if (!currentLangOnly || ul.equals(current))
            {
                org.w3c.dom.Element lang = doc.createElement(LANG_TAG);
                lang.setAttribute(LANG_TYPE_ATTRIB, langType);
                lang.setAttribute(LANG_CODE_ATTRIB, ul.getCode());
                Font font = (Font)fonts.get(ul);
                if (font != null)
                {
                    lang.setAttribute(FONT_NAME_ATTRIB, font.getName());
                    lang.setAttribute(FONT_STYLE_ATTRIB, 
                        Integer.toString(font.getStyle()));
                    lang.setAttribute(FONT_SIZE_ATTRIB, 
                        Integer.toString(font.getSize()));                
                }
                if (langType == LANG_NATIVE)
                {                
                    String name = (String)names.get(ul);
                    if (name != null && name.length() > 0)
                    {
                        lang.insertBefore(doc.createTextNode(name),null);
                    }
                }
                top.insertBefore(lang, null);
            }
        }
    }
    
    protected org.w3c.dom.Element createItemElement(org.w3c.dom.Document doc, 
                                                    TestItem item, File refDir, 
                                                    boolean currentLangOnly)
    {
        org.w3c.dom.Element itemElement = doc.createElement(TEST_TAG);
        org.w3c.dom.Element element = null;
        org.w3c.dom.Text text = null;
        // name is not really used anymoe
        //itemElement.setAttribute(TEST_NAME_ATTRIB, item.getName());
        itemElement.setAttribute(CREATOR, item.getCreator());
        itemElement.setAttribute(CREATION_TIME, 
            Long.toString(item.getCreationTime()));
        Iterator n = item.getNativeLanguages().iterator();
        while (n.hasNext())
        {
            UniversalLanguage ul = (UniversalLanguage)n.next();
            // don't save languages with empty text
            if (!currentLangOnly || 
                ul.equals(LanguageConfig.getCurrent().getNativeLanguage()))
            {
                if (item.getNativeText(ul).length()>0)
                {
                    element = doc.createElement(NATIVE_TAG);
                    element.setAttribute(TestModule.LANG_CODE_ATTRIB, ul.getCode());
                    text = doc.createTextNode(item.getNativeText(ul));
                    element.insertBefore(text,null);
                    itemElement.insertBefore(element,null);
                }
            }
        }
        Iterator f = item.getForeignLanguages().iterator();
        while (f.hasNext())
        {
            UniversalLanguage ul = (UniversalLanguage)f.next();
            if (!currentLangOnly || 
                ul.equals(LanguageConfig.getCurrent().getForeignLanguage()))
            {
                if (item.getForeignText(ul).length()>0)
                {
                    element = doc.createElement(FOREIGN_TAG);
                    element.setAttribute(TestModule.LANG_CODE_ATTRIB, ul.getCode());
                    text = doc.createTextNode(item.getForeignText(ul));
                    element.insertBefore(text,null);
                    itemElement.insertBefore(element,null);
                }
            }
        }
        if (item.getSoundFile() != null)
        {
            element = doc.createElement(SOUND_TAG);
            if (item.getPlayStart() > 0)
            {
                element.setAttribute(PLAY_START_ATTRIB,Long.toString(item.getPlayStart()));
            }
            if (item.getPlayEnd() > 0)
            {
                element.setAttribute(PLAY_END_ATTRIB,Long.toString(item.getPlayEnd()));
            }
            if (item.getSoundLength() > 0)
            {
                element.setAttribute(SOUND_LENGTH_ATTRIB,Long.toString(item.getSoundLength()));
            }
            if (refDir == null) refDir = new File("./");
            text = doc.createTextNode(RelativePath.aToB(item.getSoundFile(),refDir));
            element.insertBefore(text,null);
            itemElement.insertBefore(element,null);
        }
        if (item.getPictureFile() != null)
        {
            element = doc.createElement(PICTURE_TAG);

            if (refDir == null) refDir = new File("./");
            text = doc.createTextNode(RelativePath.aToB(item.getPictureFile(),refDir));
            element.insertBefore(text,null);
            itemElement.insertBefore(element,null);
        }
        return itemElement;
    }
    
    public boolean save()
    {            
        try
        {
            // reuse factory objects between module instances
            if (tfactory == null)
            {
                tfactory = TransformerFactory.newInstance(); 

                // This creates a transformer that does a simple identity transform, 
                // and thus can be used for all intents and purposes as a serializer.
                serializer = tfactory.newTransformer();

                Properties oprops = new Properties();
                oprops.put(OutputKeys.METHOD, "xml");
                oprops.put(OutputKeys.INDENT, "yes");
                serializer.setOutputProperties(oprops);
            }
            org.w3c.dom.Document doc = createXmlDoc(file.getParentFile(), false);
            if (doc == null) return false;
            DOMSource domSource = new DOMSource(doc);
            // now output the result
            serializer.transform(domSource, 
                                 new StreamResult(file));

            // finally try to copy the xsl file into this directory
            File xslPath = new File(file.getParent(),XSL_FILE);
            // for the moment allways copy it
            //if (!xslPath.exists())
            {
                InputStreamReader xslInputStream = 
                    new InputStreamReader(getClass().getResourceAsStream
                    ("/org.thanlwinsoft.languagetest/language/text/" + XSL_FILE));
                BufferedReader reader = new BufferedReader(xslInputStream);
                BufferedWriter writer = new BufferedWriter(new FileWriter(xslPath));
                IOUtils.getInstance().copyWriter(reader, writer);
                reader.close();
                writer.close();
            }
        }
        catch (IllegalArgumentException iae)
        {
            System.out.println(iae.toString());
            return false;
        }
        catch (TransformerConfigurationException tce)
        {
            System.out.println(tce.toString());
            return false;
        }
        catch (TransformerException te)
        {
            System.out.println(te.toString());
            return false;
        }
        catch (IOException e)
        {
            System.out.println(e.getMessage());
            // from copy of xsl file so not worth giving false for this
        }
        return true;
    }
    
    private String getElementText(org.w3c.dom.Node node)
    {
        StringBuffer buffer = new StringBuffer("");
        org.w3c.dom.Element element = (org.w3c.dom.Element)node;
        org.w3c.dom.NodeList nodes = element.getChildNodes();
        for (int t=0; t<nodes.getLength(); t++)
        {
            if (nodes.item(t).getNodeType()==org.w3c.dom.Node.TEXT_NODE)
            {
                buffer.append(nodes.item(t).getNodeValue());
            }
        }
        return buffer.toString();
    }
    
    public int compareTo(Object obj)
    {
        int comparison = 1;
        if (obj.toString() != null && obj instanceof TestModule)
        {
            TestModule otherModule = (TestModule)obj;
            comparison = getName().compareTo(otherModule.getName());
            if (comparison == 0)
            {                
                try
                {
                    comparison = file.getCanonicalPath()
                        .compareTo(otherModule.getFile().getCanonicalPath());
                }
                catch (IOException e)
                {
                    System.out.println(e);
                }
            }
        }
        else if (obj == this)
        {
            comparison = 0; 
        }
        return comparison; 
    }
    
    public boolean equals(Object obj)
    {
        TestModule otherModule = (TestModule)obj;
        boolean equal = false;
        try
        {
            equal = otherModule.getFile()
                .getCanonicalPath().equals(file.getCanonicalPath());
        }
        catch (IOException e)
        {
            System.out.println(e);
        }
        return equal;
    }
    
    public TestModule getModule()
    {
        return this;
    }
    public int getUniqueId()
    {
        return uniqueId;
    }
    public long getCreationTime()
    {
        return creationTime;
    }
    
    public class ParseException extends IOException
    {
        /**
		 * 
		 */
		private static final long serialVersionUID = 4112174696681423446L;

		ParseException(String details)
        {
            super(details);
        }
    }
}
